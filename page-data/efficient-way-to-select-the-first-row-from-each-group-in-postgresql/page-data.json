{"componentChunkName":"component---src-templates-blog-post-js","path":"/efficient-way-to-select-the-first-row-from-each-group-in-postgresql/","webpackCompilationHash":"b1bb345794198b5229c0","result":{"data":{"site":{"siteMetadata":{"title":"Coding Comrade","author":"Eugene Yamenko","siteUrl":"https://CodingComrade.com"}},"markdownRemark":{"id":"6b787ed6-9b51-5a79-abd9-6f121ad1affd","excerpt":"Recently, I encountered a situation where I had to optimize an SQL query due to PostgreSQL’s excessive CPU utilization. The query itself seemed straightforward…","html":"<p>Recently, I encountered a situation where I had to optimize an SQL query due to PostgreSQL’s excessive CPU utilization. The query itself seemed straightforward, but it was consistently taking more than 30 seconds to complete. Considering it was a frequently used query, it was causing frequent CPU spikes, impacting the performance of other queries.</p>\n<p>Here’s the original sample query:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span>\n    <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span>\n    <span class=\"token punctuation\">(</span>\n        <span class=\"token keyword\">SELECT</span>\n            tbl1<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">columns</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n            tbl2<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">columns</span><span class=\"token operator\">></span>\n        <span class=\"token keyword\">FROM</span>\n            tbl1\n            <span class=\"token keyword\">JOIN</span> tbl2 <span class=\"token keyword\">ON</span> tbl1<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> tbl2<span class=\"token punctuation\">.</span>id\n        <span class=\"token keyword\">WHERE</span>\n            tbl1<span class=\"token punctuation\">.</span>other_id <span class=\"token operator\">IN</span> <span class=\"token punctuation\">(</span>\n                <span class=\"token keyword\">SELECT</span>\n                    <span class=\"token function\">min</span><span class=\"token punctuation\">(</span>tbl1<span class=\"token punctuation\">.</span>other_id<span class=\"token punctuation\">)</span>\n                <span class=\"token keyword\">FROM</span>\n                    tbl1\n                    <span class=\"token keyword\">JOIN</span> tbl2 <span class=\"token keyword\">ON</span> tbl1<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> tbl2<span class=\"token punctuation\">.</span>id\n                <span class=\"token keyword\">WHERE</span>\n                    <span class=\"token operator\">&lt;</span><span class=\"token keyword\">some</span> conditions<span class=\"token operator\">></span>\n                <span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span>\n                    tbl1<span class=\"token punctuation\">.</span>other_id\n            <span class=\"token punctuation\">)</span>\n        <span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span>\n            tbl1<span class=\"token punctuation\">.</span>other_id\n    <span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> innerQuery\n<span class=\"token keyword\">LIMIT</span> <span class=\"token number\">300</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Accompanied by its execution plan:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> Limit  (cost=11686.42..12241.94 rows=300 width=371) (actual time=31094.513..31094.518 rows=1 loops=1)\n   -&gt;  Nested Loop  (cost=11686.42..7597359.01 rows=4118716 width=371) (actual time=31094.512..31094.517 rows=1 loops=1)\n         -&gt;  Merge Join  (cost=11686.13..6340599.52 rows=4118716 width=243) (actual time=31094.478..31094.483 rows=1 loops=1)\n               Merge Cond: (tbl1.other_id = &quot;ANY_subquery&quot;.min)\n               -&gt;  Index Scan using &lt;some idx&gt; on tbl1  (cost=0.56..6308317.36 rows=8237433 width=243) (actual time=0.016..30363.563 rows=7959843 loops=1)\n               -&gt;  Sort  (cost=11685.57..11686.07 rows=200 width=8) (actual time=0.628..0.629 rows=1 loops=1)\n                     Sort Key: &quot;ANY_subquery&quot;.min\n                     Sort Method: quicksort  Memory: 25kB\n                     -&gt;  HashAggregate  (cost=11675.93..11677.93 rows=200 width=8) (actual time=0.616..0.619 rows=1 loops=1)\n                           Group Key: &quot;ANY_subquery&quot;.min\n                           -&gt;  Subquery Scan on &quot;ANY_subquery&quot;  (cost=11613.16..11674.72 rows=482 width=8) (actual time=0.613..0.613 rows=1 loops=1)\n                                 -&gt;  Finalize GroupAggregate  (cost=11613.16..11669.90 rows=482 width=16) (actual time=0.612..0.612 rows=1 loops=1)\n                                       Group Key: tbl1.other_id\n                                       -&gt;  Gather Merge  (cost=11613.16..11663.07 rows=402 width=16) (actual time=0.610..0.730 rows=1 loops=1)\n                                             Workers Planned: 2\n                                             Workers Launched: 0\n                                             -&gt;  Partial GroupAggregate  (cost=10613.13..10616.65 rows=201 width=16) (actual time=0.104..0.104 rows=1 loops=1)\n                                                   Group Key: tbl1.other_id\n                                                   -&gt;  Sort  (cost=10613.13..10613.63 rows=201 width=16) (actual time=0.102..0.102 rows=1 loops=1)\n                                                         Sort Key: tbl1.other_id\n                                                         Sort Method: quicksort  Memory: 25kB\n                                                         -&gt;  Nested Loop Left Join  (cost=1.53..10605.44 rows=201 width=16) (actual time=0.066..0.093 rows=1 loops=1)\n                                                               Filter: ((&lt;condition1&gt;) OR (&lt;condition2&gt;))\n                                                               -&gt;  Nested Loop  (cost=0.97..9964.02 rows=248 width=24) (actual time=0.054..0.081 rows=1 loops=1)\n                                                                     -&gt;  Parallel Index Scan using &lt;some idx&gt; on tbl1  (cost=0.68..9158.50 rows=1125 width=32) (actual time=0.040..0.067 rows=1 loops=1)\n                                                                           Index Cond: (&lt;condition&gt;)\n                                                                           Filter: (&lt;condition&gt;)\n                                                                           Rows Removed by Filter: 2\n                                                                     -&gt;  Index Scan using &lt;some idx&gt; on tbl2  (cost=0.29..0.72 rows=1 width=8) (actual time=0.012..0.012 rows=1 loops=1)\n                                                                           Index Cond: (&lt;condition&gt;)\n                                                                           Filter: (&lt;condition&gt;)\n         -&gt;  Index Scan using &lt;some idx&gt; on tbl2  (cost=0.29..0.31 rows=1 width=136) (actual time=0.025..0.025 rows=1 loops=1)\n               Index Cond: (&lt;condition&gt;)\n Planning time: 1.531 ms\n Execution time: 31094.852 ms</code></pre></div>\n<p>As can be seen, the query essentially retrieves the first row from a group of rows, yet it takes a staggering 31 seconds!</p>\n<p>PostgreSQL offers a unique statement called <code class=\"language-text\">SELECT DISTINCT ON</code> specifically designed to achieve this goal in a much more efficient manner. It eliminates rows that match on all the specified expressions, ensuring that only the first distinct row for each group is returned.</p>\n<p>Here’s the optimized query using <code class=\"language-text\">SELECT DISTINCT ON</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">select</span>\n    <span class=\"token operator\">*</span>\n<span class=\"token keyword\">from</span>\n    <span class=\"token punctuation\">(</span>\n        <span class=\"token keyword\">select</span>\n            <span class=\"token keyword\">distinct</span> <span class=\"token keyword\">on</span> <span class=\"token punctuation\">(</span>tbl1<span class=\"token punctuation\">.</span>other_id<span class=\"token punctuation\">)</span> tbl1<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">columns</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span> tbl2<span class=\"token punctuation\">.</span><span class=\"token operator\">&lt;</span><span class=\"token keyword\">columns</span><span class=\"token operator\">></span>\n        <span class=\"token keyword\">from</span>\n            tbl1\n            <span class=\"token keyword\">join</span> tbl2 <span class=\"token keyword\">on</span> tbl1<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> tbl2<span class=\"token punctuation\">.</span>id\n        <span class=\"token keyword\">where</span>\n            <span class=\"token operator\">&lt;</span><span class=\"token keyword\">some</span> conditions<span class=\"token operator\">></span>\n        <span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span>\n            tbl1<span class=\"token punctuation\">.</span>other_id<span class=\"token punctuation\">,</span>\n            tbl1<span class=\"token punctuation\">.</span>id\n    <span class=\"token punctuation\">)</span> <span class=\"token keyword\">as</span> q\n<span class=\"token keyword\">order</span> <span class=\"token keyword\">by</span>\n    id\n<span class=\"token keyword\">limit</span>\n    <span class=\"token number\">300</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>This query’s execution plan is as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> Limit  (cost=11082.00..11082.75 rows=300 width=371) (actual time=2.102..2.104 rows=8 loops=1)\n   -&gt;  Sort  (cost=11082.00..11083.13 rows=454 width=371) (actual time=2.101..2.102 rows=8 loops=1)\n         Sort Key: q.id\n         Sort Method: quicksort  Memory: 29kB\n         -&gt;  Subquery Scan on q  (cost=11055.15..11061.96 rows=454 width=371) (actual time=2.044..2.063 rows=8 loops=1)\n               -&gt;  Unique  (cost=11055.15..11057.42 rows=454 width=379) (actual time=2.042..2.053 rows=8 loops=1)\n                     -&gt;  Sort  (cost=11055.15..11056.28 rows=454 width=379) (actual time=2.041..2.042 rows=8 loops=1)\n                           Sort Key: tbl1.other_id, tbl1.id\n                           Sort Method: quicksort  Memory: 29kB\n                           -&gt;  Gather  (cost=1001.53..11035.11 rows=454 width=379) (actual time=1.505..2.116 rows=8 loops=1)\n                                 Workers Planned: 2\n                                 Workers Launched: 0\n                                 -&gt;  Nested Loop Left Join  (cost=1.53..9989.71 rows=189 width=379) (actual time=0.235..0.747 rows=8 loops=1)\n                                       Filter: (&lt;some conditions&gt;)\n                                       Rows Removed by Filter: 3\n                                       -&gt;  Nested Loop  (cost=0.97..9387.10 rows=233 width=379) (actual time=0.090..0.514 rows=11 loops=1)\n                                             -&gt;  Parallel Index Scan using &lt;idx&gt; on tbl1  (cost=0.68..8600.52 rows=1059 width=251) (actual time=0.057..0.351 rows=19 loops=1)\n                                                   Index Cond: (&lt;condition&gt;)\n                                                   Filter: (&lt;condition&gt;)\n                                                   Rows Removed by Filter: 14\n                                             -&gt;  Index Scan using &lt;idx&gt; on tbl2  (cost=0.29..0.74 rows=1 width=136) (actual time=0.008..0.008 rows=1 loops=19)\n                                                   Index Cond: (&lt;condition&gt;)\n                                                   Filter: (&lt;condition&gt;)\n                                                   Rows Removed by Filter: 0\n Planning time: 4.296 ms\n Execution time: 2.547 ms</code></pre></div>\n<p>Remarkably, the execution time drops to just 2 milliseconds, representing a staggering 99.9999% improvement!</p>\n<p>Key Takeaways:</p>\n<ul>\n<li><code class=\"language-text\">SELECT DISTINCT ON</code> is a PostgreSQL-specific statement for efficiently selecting the first row from each group.</li>\n<li>Ordering rows is crucial when using <code class=\"language-text\">SELECT DISTINCT ON</code>; otherwise, the order becomes unpredictable.</li>\n<li>Replacing the original query with the optimized <code class=\"language-text\">SELECT DISTINCT ON</code> approach significantly reduces execution time and improves overall query performance.</li>\n</ul>\n<p>I hope this blog post has shed light on the efficient way to select the first row from each group in PostgreSQL using <code class=\"language-text\">SELECT DISTINCT ON</code>. Remember to always optimize queries to ensure optimal database performance.</p>\n<p>Happy coding!</p>","frontmatter":{"title":"Efficient way to select the first row from each group in PostgreSQL","date":"November 29, 2023","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/efficient-way-to-select-the-first-row-from-each-group-in-postgresql/","previous":{"fields":{"slug":"/using-resource-account-context-key-to-scope-down-iam-role-permissions/"},"frontmatter":{"title":"Using ResourceAccount context key to scope down IAM role permissions"}},"next":null}}}