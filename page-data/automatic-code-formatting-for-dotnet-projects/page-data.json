{"componentChunkName":"component---src-templates-blog-post-js","path":"/automatic-code-formatting-for-dotnet-projects/","webpackCompilationHash":"b1bb345794198b5229c0","result":{"data":{"site":{"siteMetadata":{"title":"Coding Comrade","author":"Eugene Yamenko","siteUrl":"https://CodingComrade.com"}},"markdownRemark":{"id":"773660ab-d7fc-55ba-89f1-5585ce9c094c","excerpt":"Every programmer has its own coding style preferences, but software development teams should have a well defined standards. It makes it easier to maintain the…","html":"<p>Every programmer has its own coding style preferences, but software development teams should have a well defined standards. It makes it easier to maintain the project, read the code, review pull requests, etc. Team mates join and leave. If there is no common ground, projects start looking like a collection of unrelated things.</p>\n<p>To solve this issue, community created a wide variety of tools. For instance, there is an awesome project called <a href=\"https://prettier.io/\">Prettier</a>. It formats, or how they call it — <em>prettifies</em>, certain files. Unfortunately, it doesn’t support .NET languages, but don’t get upset. There is something out there that can help us keep our .NET codebases consistent.</p>\n<p>Kind people from Microsoft created a handy dotnet tool - <a href=\"https://github.com/dotnet/format\">dotnet-format</a>. It reads style preferences from an <a href=\"https://editorconfig.org/\">.editorconfig</a> file and formats files accordingly. As a bonus, Visual Studio supports <em>.editorconfig</em> rules as well and can apply them when the code is formatted manually. Looks like we’ve got everything in place now, we can relax and stop worrying about style preferences and formatting. The solution/project can be initially formatted by the <em>dotnet-format</em> and then, before committing a change, each developer will have to make sure they format their change in Visual Studio manually. There is one little problem here though, people tend to forget things. We can do better. We can automate it.</p>\n<p>.NET Core 3.0 introduced a concept of <a href=\"https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0#local-tools\">local dotnet tools</a>. It’s similar to local executable <em>npm</em> scripts. We can install the <em>dotnet-format</em> as a local tool and then make it format staged files when someone commits the code.</p>\n<ol>\n<li>Create a dotnet tools manifest file:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">dotnet new tool-manifest</code></pre></div>\n<ol start=\"2\">\n<li>Install the <em>dotnet-format</em>:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">dotnet tool <span class=\"token function\">install</span> dotnet-format</code></pre></div>\n<ol start=\"3\">\n<li>Add an <em>.editorconfig</em> file to the root of the project. I suggest to use <a href=\"https://github.com/dotnet/roslyn/blob/master/.editorconfig\">Roslyn team’s config file</a> as a base.</li>\n<li>Initialize an <em>npm</em> project:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">yarn</span> init</code></pre></div>\n<ol start=\"5\">\n<li>Install the following <em>npm</em> packages as dev dependencies:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">yarn</span> <span class=\"token function\">add</span> husky lint-staged --dev</code></pre></div>\n<ol start=\"6\">\n<li>Configure <em>husky</em> to run <em>lint-staged</em> as a pre-commit <em>git</em> hook; and configure <em>npm</em> to restore dotnet tools on install. Add the following to <em>package.json</em>:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token property\">\"husky\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"hooks\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token property\">\"pre-commit\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"lint-staged -r\"</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token property\">\"scripts\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token property\">\"preinstall\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"dotnet tool restore\"</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ol start=\"7\">\n<li>The last step is to configure <em>lint-staged</em> to format our staged files and then stage them back. Create a <em>.lintstagedrc.js</em> file with the below content:</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">module<span class=\"token punctuation\">.</span>exports <span class=\"token operator\">=</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token string\">'*.cs'</span><span class=\"token punctuation\">:</span> <span class=\"token parameter\">filenames</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">[</span>\n    <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">dotnet dotnet-format --files </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>filenames<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">','</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n    <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">git add </span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>filenames<span class=\"token punctuation\">.</span><span class=\"token function\">join</span><span class=\"token punctuation\">(</span><span class=\"token string\">' '</span><span class=\"token punctuation\">)</span><span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><br>\nThat’s it. I’ve created a <a href=\"https://github.com/eyamenko/dotnet-core-template-repository\">template repository</a>, which includes everything I’ve mentioned above; and can be used as a starting point when creating new .NET Core repositories.</p>\n<p>Happy coding!</p>","frontmatter":{"title":"Automatic code formatting for .NET projects","date":"September 29, 2019","description":null}}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/automatic-code-formatting-for-dotnet-projects/","previous":{"fields":{"slug":"/living-the-full-stack-life/"},"frontmatter":{"title":"Living the Full-Stack Life"}},"next":{"fields":{"slug":"/robust-caching-with-redis/"},"frontmatter":{"title":"Robust caching with Redis"}}}}}